package com.manniu;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import org.apache.tools.zip.ZipEntry;import org.apache.tools.zip.ZipFile;import org.apache.tools.zip.ZipOutputStream;public class ZipFileUtil{private static final int BUFFEREDSIZE = 1024;public static void main(String[] args) throws Exception{	String filePath = "C:\\Users\\pc\\Desktop\\身份认证\\3.jpg";	ZipFileUtil.zip(filePath, filePath+".zip");}public static void print(String text){	System.out.println("print:" + text);}/*** 解压zip格式的压缩文件解压到指定位置* @param zipFileName 压缩文件* @param extPlace 解压目录* @throws Exception*/@SuppressWarnings("rawtypes")public static void unzip(String zipFileName, String extPlace){   try   {    (new File(extPlace)).mkdirs();    ZipFile zipFile = new ZipFile(zipFileName);   // if (FileUtil.isExist(zipFileName))    	if (new File(zipFileName).exists())    {	     String strPath, gbkPath, strtemp;     File tempFile = new File(extPlace);     strPath = tempFile.getAbsolutePath();     java.util.Enumeration e = zipFile.getEntries();     while (e.hasMoreElements())     {      org.apache.tools.zip.ZipEntry zipEnt = (ZipEntry) e.nextElement();      gbkPath = zipEnt.getName();      if (zipEnt.isDirectory())      {       strtemp = strPath + File.separator + gbkPath;       File dir = new File(strtemp);       dir.mkdirs();       continue;      }      else      {       //读写文件          InputStream is = zipFile.getInputStream(zipEnt);       BufferedInputStream bis = new BufferedInputStream(is);       gbkPath = zipEnt.getName();       strtemp = strPath + File.separator + gbkPath;       //建目录          String strsubdir = gbkPath;       for (int i = 0; i < strsubdir.length(); i++)       {        if (strsubdir.substring(i, i + 1).equalsIgnoreCase("/"))        {         String temp = strPath + File.separator + strsubdir.substring(0, i);         File subdir = new File(temp);         if (!subdir.exists())          subdir.mkdir();        }       }       FileOutputStream fos = new FileOutputStream(strtemp);       BufferedOutputStream bos = new BufferedOutputStream(fos);	    int c;       while ((c = bis.read()) != -1)       {        bos.write((byte) c);       }       bos.close();       fos.close();      }     }    }   }   catch (Exception e)   {    e.printStackTrace();   }} /*** 压缩zip格式的压缩文件* @param inputFilename 压缩的文件或文件夹及详细路径* @param zipFilename 输出文件名称及详细路径* @throws IOException*/public static void zip(String inputFilename, String zipFilename){   zip(new File(inputFilename), zipFilename);}/*** 压缩zip格式的压缩文件* @param inputFile 需压缩文件* @param zipFilename 输出文件及详细路径* @throws IOException*/public static void zip(File inputFile, String zipFilename){   ZipOutputStream out;   try   {    out = new ZipOutputStream(new FileOutputStream(zipFilename));    zip(inputFile, out, "");   }   catch (Exception e)   {    e.printStackTrace();   }}/*** 压缩zip格式的压缩文件* @param inputFile 需压缩文件* @param out 输出压缩文件* @param base 结束标识* @throws IOException*/private static void zip(File inputFile, ZipOutputStream out, String base) throws IOException{   if (inputFile.isDirectory()){	   print("directory");    File[] inputFiles = inputFile.listFiles();    out.putNextEntry(new ZipEntry(base + "/"));    base = base.length() == 0 ? "" : base + "/";    for (int i = 0; i < inputFiles.length; i++)    {     zip(inputFiles[i], out, base + inputFiles[i].getName());    }   }   else {	   print("file:" + inputFile.getAbsolutePath());    if (base.length() > 0)    {     out.putNextEntry(new ZipEntry(base));    }    else    {     out.putNextEntry(new ZipEntry(inputFile.getName()));    }    FileInputStream in = new FileInputStream(inputFile);    try    {     int c;     byte[] by = new byte[BUFFEREDSIZE];     while ((c = in.read(by)) != -1)     {      out.write(by, 0, c);     }    }    catch (IOException e)    {     throw e;    }    finally    {     in.close();    }   }}}